package org.hexmonad.msc2gen;

import java.io.IOException;
import java.io.PrintStream;
import java.util.*;

import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;

public class MscParser {
    private PrintStream outStream;
    private ArrayList<String> lifelines = new ArrayList<String>();
    private boolean instFlag = true;    // true while parsing of instance declarations
    
    // contains tuple (message name --> message sender name)
    private HashMap<String, String> msgSender = new HashMap<String, String>();
    private HashMap<String, String> msgReceiver = new HashMap<String, String>();

    public void parse(String mscFileName, String outFileName) throws IOException, RecognitionException {
        ANTLRFileStream char_stream = new ANTLRFileStream( mscFileName );
        msc_grammarLexer lexer = new msc_grammarLexer( char_stream );
        CommonTokenStream tokens = new CommonTokenStream( lexer );
        
        msc_grammarParser parser = new msc_grammarParser( tokens );
        CommonTree tree = (CommonTree) parser.messageSequenceChart().getTree();
        System.out.println(tree.toStringTree());
        
        // get MSC name
        String mscName = tree.getChild(0).getChild(0).toString();
        outFileName = ( outFileName == null ? mscName + ".signalling" : outFileName );
        
        outStream = new PrintStream(outFileName);
        outStream.println("# This file was generated by msc2gen tool (https://github.com/HexMonad/msc2gen).");
        outStream.println("title: " + mscName + ";");
        outStream.println("hscale=auto;");        
        
        //parse MSC Body only
        parseTree( tree.getChild(1), null, "    " );
        
        outStream.close();
    }
    
    private void parseTree(Tree tree, List<String> instList, String indentLevel) {
        String token = tree.getText();
        
        if (token.equals("MSCBody")) {
            parseChildTree(tree, instList, indentLevel);
            
        } else if (token.equals("Instance")) {
            String instName = tree.getChild(0).getText();
            
            if (tree.getChild(1).getText().equals("instance")) {
                String commaSign = ( lifelines.isEmpty() ? "" : ", " );
                outStream.print(commaSign + instName);
                lifelines.add(instName);
            } else if (instFlag) {
                // end of instance declarations
                outStream.println(";\n");
                instFlag = false;
            }
            
            instList = new ArrayList<String>();
            instList.add(instName);
            parseChildTree(tree, instList, indentLevel);
        
        } else if (token.equals("InstanceList")) {
            instList = new ArrayList<String>();
            Tree instNameTree = tree.getChild(0);
            
            for(int i = 0; i < instNameTree.getChildCount(); i++) {
                instList.add(instNameTree.getChild(i).getText());
            }
            parseChildTree(tree, instList, indentLevel);
        
        } else if (token.equals("MSGIn")) {
            String lifeline = instList.get(0);
            String msg = tree.getChild(0).getText().replaceAll("^\'|\'$", "");
            
            if (tree.getChild(1).getText().equals("MsgGate")) {                 // message input from ENV
                outStream.println("->" + lifeline + ": " + msg + ";");
            
            } else if (msgSender.get(msg) != null) {
                outStream.println(msgSender.get(msg) + "->" + lifeline + ": " + msg + ";");
                msgSender.put(msg, null);
            
            } else {
                msgReceiver.put(msg, lifeline);
            }
            
        } else if (token.equals("MSGOut")) {
            String lifeline = instList.get(0);
            String msg = tree.getChild(0).getText().replaceAll("^\'|\'$", "");
            String receiver = tree.getChild(1).getText();
            
            if (receiver.equals("MsgGate")) {                 // message output to ENV
                outStream.println(lifeline + "->: " + msg + ";");
            
            } else if (tree.getChild(2).getText().equals("IncompleteMsg")) {    // lost of message
                outStream.println(lifeline + "->*" + receiver + ": " + msg + " [text.ident = left];");
            
            } else if (msgReceiver.get(msg) != null) {
                outStream.println(lifeline + "->" + msgReceiver.get(msg) + ": " + msg + ";");
                msgReceiver.put(msg, null);
            
            } else {
                msgSender.put(msg, lifeline);
            }
        
        } else if (token.equals("Action")) {
            String lifeline = instList.get(0);
            String text = tree.getChild(0).getText().replaceAll("^\'|\'$", "");
            outStream.println(lifeline + "--" + lifeline + ": " + text + ";");
                
        } else if (token.equals("Condition")) {
            String condTypeStr = "";
            String condTextStr = "";
            if (!tree.getChild(0).equals("ElseCond")) {
                condTextStr = tree.getChild(1).getText().replaceAll("^\'|\'$", "");
                if (tree.getChild(0).equals("GuardCond")) {
                    condTypeStr = " \bwhen\b";
                }
            } else {
                condTypeStr = " \botherwise\b";
            }
            outStream.println(listJoin(instList, "--") + ":" + condTypeStr + " " + condTextStr
                    + " [line.radius=15, line.corner=bevel];");
            
        } else if (token.equals("Ref")) {
            String refText = tree.getChild(0).getText().replaceAll("^\'|\'$", "");
            outStream.println(listJoin(instList, "--") + ": " + refText + " [line.radius=10];");
        }
    }
    
    private void parseChildTree(Tree tree, List<String> instList, String indentLevel) {
        int num = tree.getChildCount();
        for(int i = 0; i < num; i++) {
            parseTree(tree.getChild(i), instList, indentLevel);
        }
    }
    
    private static String listJoin(Collection<String> collection, String delim) {
        StringBuilder sb = new StringBuilder();
        String loopDelim = "";
        
        for (String str : collection) {
            sb.append(loopDelim);
            sb.append(str);
            loopDelim = delim;
        }
        return sb.toString();
    }    
}
